---
author: azu
---

# イベントとモデル {#event-model}

Todoアイテムを追加する機能を実装しましたが、イベントを受け取り直接DOMを更新する方法は柔軟性がなくなるという問題があります。

まずは実際にどのような点で問題が起きやすかについて考えていきます。
その後、柔軟性を確保するために**モデル**という概念を加えて、あらためてTodoアイテムの追加機能を見ていきます。

## 直接DOMを更新する問題 {#direct-dom-modification-issue}

[前のセクション][]では、操作した結果発生したイベントの発火という入力に対して、DOM（表示）の更新という出力が1対1でおこなわれていました。
つまりTodoリストにTodoアイテムが何個あるか、どのようなアイテムがあるかという状態がDOM上にしか存在しないことになります。

そのため、Todoアイテムの状態を更新するには、DOM要素にTodoアイテムの情報（タイトルや識別子となるidなど）をすべて埋め込む必要があります。
一方、DOM要素に対して文字列でしか情報を入れることができません。
そのため、直接DOM要素に状態を持たせると、Todoアイテムに含まれるデータは文字列にできないといけないという制限が発生します。

また操作と表示が1対1で更新される場合、1つの操作に対して複数の箇所の表示が更新されることもあります。
今回のTodoアプリでもTodoリスト(`#js-todo-list`)とTodoアイテム数（`#js-todo-count`)の2箇所を更新する必要があることからも分かります。

次の表に**操作**に対して更新する**表示**をまとめてみます。

| 機能               | 操作                       | 表示                                                                                                                   |
| ------------------ | -------------------------- | ---------------------------------------------------------------------------------------------------------------------- |
| Todoアイテムの追加 | フォームを入力し送信       | Todoリスト(`#js-todo-list`)にTodoアイテム要素を作成し子要素として追加。合わせてTodoアイテム数（`#js-todo-count`)を更新 |
| Todoアイテムの更新 | チェックボックスをクリック | Todoリスト(`#js-todo-list`)次の指定したTodoアイテム要素のチェック状態を更新                                            |
| Todoアイテムの削除 | 削除ボタンをクリック       | Todoリスト(`#js-todo-list`)次の指定したTodoアイテム要素を削除。合わせてTodoアイテム数（`#js-todo-count`)を更新         |

これは表示を更新しなければいけない箇所が増えるほど、操作に対する処理が複雑化していくことが予想できます。

ここでは次の2つの問題が見つかりました。

- Todoリストの状態がDOM上にしか存在しないため、状態をすべてDOM上に文字列で埋め込まないといけない
- 操作に対して更新する表示箇所が増えてくると、表示の処理が複雑化する

## モデルを導入する {#introduce-model}

この問題を避けるために、Todoアイテムという情報をただのJavaScriptクラスとしてモデル化します。
ここでのモデルとはTodoItemやTodolistといった**もの**をクラスで表現し、操作や状態をもたせたオブジェクトという意味です。

たとえば、Todoリストを表現するモデルとして`TodoList`クラスを考えます。
TodoリストにはTodoアイテムを追加できるので`TodoList#addItem`メソッドを実装する必要があります。
また、Todoリストからアイテムの一覧を取得できる必要もあるので`TodoList#getAllItems`メソッドも必要です。
このようにTodoリストをクラスで表現する際にオブジェクトがどのような処理や状態をもつかを考え実装することをモデル化とよびます。

このようにモデルを考え、先ほどの操作と表示の間にモデルを入れることを考えてみます。
「フォームを入力し送信」という**操作**を行った場合、`TodoList`という**モデル**に対して`TodoItem`を追加します。
そして、`TodoList`というモデルからアイテムの一覧を取得し、DOMを組み立て**表示**を更新します。

先ほどの表にモデルをいれてみます。
**操作**に対する**モデルの処理**はさまざまですが、**操作**に対する**表示**の処理はどの場合も同じになります。
これは表示箇所が増えた場合も**表示**の処理の複雑さが一定に保てることを意味しています。

| 機能               | 操作                       | モデルの処理                           | 表示                     |
| ------------------ | -------------------------- | -------------------------------------- | ------------------------ |
| Todoアイテムの追加 | フォームを入力し送信       | TodoListへ新しいTodoItemを追加             | TodoListを元に表示を更新 |
| Todoアイテムの更新 | チェックボックスをクリック | TodoListの指定したTodoItemの状態を更新 | TodoListを元に表示を更新 |
| Todoアイテムの削除 | 削除ボタンをクリック       | TodoListから指定のTodoItemを削除       | TodoListを元に表示を更新 |

この表を元にあらためて先ほどの問題点を見ていきましょう。

> Todoリストの状態がDOM上にしか存在しないため、状態をすべてDOM上に文字列で埋め込まないといけない

モデルを参照すれば情報が手に入るので、DOMにすべての情報を埋め込む必要はありません。
またモデルはただのJavaScriptクラスであるため、文字列ではない情報も保持できます。

> 操作に対して更新する表示箇所が増えてくると、表示の処理が複雑化する

表示はモデルの状態を元にしてHTML要素を作成し表示を更新します。
モデルの状態が変化していなければ、表示は変わらなくても問題ありません。

そのため操作したタイミングではなく、モデルの状態が変化したタイミングで表示を更新すればよいはずです。
具体的には「フォームを入力し送信」されたから表示を更新するのではなく、
「`TodoList`というモデルの状態が変化」したから表示を更新すればいいはずです。

そのためには、`TodoList`というモデルの状態が変化したことを表示側から知る必要があります。
ここで再び出てくるのがイベントです。

## モデルの変化を伝えるイベント {#model-and-event}

フォームを送信したらform要素から`submit`イベントが発火されます。
これと同じように`TodoList`モデルの状態が変化したら`change`イベントを発火すれば、
表示はそのイベントを監視してイベントが発火したら表示を更新すればよいはずです。

`TodoList`モデルの状態の変化とは、「`TodoList`に新しい`TodoItem`が追加される」などが該当します。
先ほど表の「モデルの処理」は何かしら状態が変化しているので、表示を更新する必要があるわけです。

DOM APIのイベントの仕組みをモデルでも利用できれば、モデルが更新されたら表示を更新する仕組みを作れそうです。
ブラウザのDOM APIではこれらのイベントをDOM Eventsと呼びますが、Node.jsでは`events`と呼ばれるモジュールで同様のイベントの仕組みが利用できます。
ここではイベントの仕組みを理解するために、イベントの発火と監視する機能をもつクラスを作ってみましょう。

とても難しく聞こえますが、今まで学んだクラスやコールバック関数などを使えば実現できます。

## EventEmitter {#event-emitter}

イベントの仕組みとはイベントを発火する側（Publisher）とイベントを監視する側（Subscriber）の2つの面から成り立ちます。
場合によっては、自分自身へイベントを発火し自分自身でイベントを監視することもあります。

このイベントを仕組みをコード的に表現してみると「特定の関数を呼び出した（イベントを発火）ときに登録されている（イベントを監視側の）コールバック関数を呼び出す」となります。

モデルが更新されたら表示を更新するには「`TodoList`モデルが更新したときに指定したコールバック関数を呼び出すクラス」を作れば目的は達成できます。
しかし、「`TodoList`モデルが更新されたとき」というのはとても具体的な処理であるため、モデルを増やすたびに同じ処理をそれぞれのモデルへ実装する必要があります。

そのため、先ほどのイベントの仕組みを持った概念として`EventEmitter`というクラスを作成します。
そして`TodoList`モデルは作成した`EventEmitter`を継承することでイベントの仕組みを導入していきます。

- 親クラス（`EventEmitter`): イベントを発火した時、登録されているコールバックを呼び出すクラス
- 子クラス（`TodoList`）: 値を更新した時にコールバック関数を呼び出すクラス

クラスでは親クラスになるほど概念的（抽象的）なものが多くなり、子クラスほど具体的になる傾向があります。
概念的な親クラスはインスタンス化せずに単純に継承するために定義されることがあります。
一方、子クラスはインスタンス化して利用するので用途がより明確なものなるため、このような傾向が考えられます。

まずは、親クラスとなる`EventEmitter`を作成していきます。

`EventEmitter`はさきほどのイベントの仕組みで書いた２つの側面を実装するクラスとなります。

- 監視側: `addEventLister`メソッドは、指定した`イベント名`に任意のコールバック関数を登録できる
- 発火側: `emit`メソッドは、指定された`イベント名`に登録済みのすべてのコールバック関数を呼び出す

これによって、`emit`メソッドを呼び出すと指定したイベントに関係する登録済みのコールバック関数を呼び出せます。
このようなパターンはObserverパターンとも呼ばれ、ブラウザやNode.jsなど多くの実行環境で似たAPIが実装されています。

次のように`src/EventEmitter.js`へ`EventEmitter`クラスを定義します。

[import, title:"src/EventEmitter.js"](./event-emitter/src/EventEmitter.js)

この`EventEmitter`は次のようにイベントの監視とイベントの発火の機能が利用できます。

<!-- doctest:disable -->
```js
import { EventEmitter } from "./src/EventEmitter.js";
const event = new EventEmitter();
// コールバック関数を登録
event.addEventLister(() => console.log("One!"));
event.addEventLister(() => console.log("Two!"));
// コールバック関数をまとめて呼びだす
event.emit();
// コールバック関数がそれぞれよびだされ、コンソールには次のように出力される
// "One!"
// "Two!"
```

## EventEmitterを継承したTodoListモデル {#event-emitter-todolist-model}

次に作成した`EventEmitter`クラスを継承した`TodoList`を表現するモデルクラスを作成しています。
`src/model/`ディレクトリを新たに作成し、このディレクトリに各モデルクラスを実装したファイルを作成します。

作成するモデルは、Todoリストを表現する`TodoList`モデルと各Todoアイテムを表現する`TodoItem`モデルです。
`TodoList`モデルが複数の`TodoItem`を保持することでTodoリストを表現することになります。

まずは`TodoItem`モデルを`src/model/TodoItem.js`へ作成します。

`TodoItem`クラスは各Todoアイテムに必要な情報を定義します。
各Todoアイテムにはタイトル（`title`)、アイテムの完了状態（`completed`)、またそれぞれのアイテムを識別するユニークな`id`をもたせます。
ただのデータの集合であるため、クラスではなくオブジェクトでも違いはありませんが、今回は`TodoItem`クラスとして作成します。

次のように`TodoItem`クラスを定義します。

[import, title:"src/model/TodoItem.js"](./event-emitter/src/model/TodoItem.js)

次のコードでは`TodoItem`クラスはインスタンス化でき、それぞれの`id`が自動的に異なる値となっていることが確認できます。
この`id`は後ほど特定のTodoアイテムを指定した更新する処理際に、アイテムを区別する識別子として利用します。

[import src/model/TodoItem.example.js](./event-emitter/src/model/TodoItem.example.js)

次に`TodoList`モデルを`src/model/TodoList.js`へ作成します。

`TodoList`クラスは、先ほど作成した`EventEmitter`クラスを継承します。
`TodoList`クラスは`TodoItem`の配列を保持し、新しいTodoアイテムを追加する際はその配列に追加します。
このとき`TodoList`の状態が変わるため変更を通知するために自分自身へ`change`イベントを発火します。

[import, title:"src/model/TodoList.js"](./event-emitter/src/model/TodoList.js)

次のコードは`TodoList`クラスを取り込み、新しい`TodoItem`を追加するサンプルコードです。
`TodoList#addTodo`メソッドで新しい`TodoItem`を追加した時に、`TodoList#onChange`で登録したイベントハンドラが呼び出されていることが確認できます。

[import, "src/model/TodoList.example.js"](./event-emitter/src/model/TodoList.example.js)

これで、Todoリストに必要なそれぞれのモデルクラスが作成できました。
次は、これらのモデルを使って実際に表示の更新を行いましょう。

## モデルを使って表示を更新する {#model-update-view}

さきほど作成した`TodoList`と`TodoItem`クラスを使い、Todoアイテムの追加を書き直してみます。

まずは書き換え後の`App.js`を見ていきます。

[import, "src/model/TodoList.example.js"](./event-emitter/src/model/TodoList.example.js)


- [ ] renderは事前にかいていてう

[前のセクション]: ../form-event/README.md
